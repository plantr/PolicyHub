---
phase: 02-storage-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/0004_storage_buckets.sql
  - supabase/migrations/0005_storage_rls.sql
  - server/storage-supabase.ts
autonomous: true
requirements:
  - STOR-01
  - STOR-02
  - STOR-03
  - STOR-04

must_haves:
  truths:
    - "A private storage bucket exists for each business unit in Supabase Storage"
    - "RLS policies on storage.objects restrict SELECT/INSERT/DELETE to users who are members of the BU that owns the bucket"
    - "Server-side functions can generate signed upload URLs for a given BU and file path"
    - "Server-side functions can generate signed download URLs (inline preview + forced download) for a given BU and file path"
    - "Server-side functions can delete storage objects from a BU's bucket"
  artifacts:
    - path: "supabase/migrations/0004_storage_buckets.sql"
      provides: "Storage bucket creation for all existing business units"
      contains: "INSERT INTO storage.buckets"
    - path: "supabase/migrations/0005_storage_rls.sql"
      provides: "RLS policies on storage.objects for BU-scoped access"
      contains: "CREATE POLICY"
    - path: "server/storage-supabase.ts"
      provides: "Supabase Storage service module with signed URL generation, delete, filename resolution"
      exports: ["bucketName", "storagePath", "createSignedUploadUrl", "createSignedDownloadUrl", "deleteStorageObject", "resolveFilename", "createBucketForBusinessUnit", "ALLOWED_MIME_TYPES", "MAX_FILE_SIZE"]
  key_links:
    - from: "server/storage-supabase.ts"
      to: "server/lib/supabase-admin.ts"
      via: "imports supabaseAdmin for service-role storage operations"
      pattern: "import.*supabaseAdmin.*from.*supabase-admin"
    - from: "supabase/migrations/0005_storage_rls.sql"
      to: "supabase/migrations/0002_auth_hook.sql"
      via: "RLS policies reference same JWT claims path as Phase 1"
      pattern: "auth.jwt\\(\\)->.*app_metadata.*business_units"
---

<objective>
Create the Supabase Storage foundation: SQL migrations for per-BU private buckets with RLS enforcement, and the server-side storage service module that all routes will use.

Purpose: Establishes the storage layer that Phase 2 routes depend on — buckets, security policies, and the TypeScript interface for signed URL generation and file management.
Output: Two SQL migrations (0004 buckets, 0005 RLS) and server/storage-supabase.ts module.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-storage-migration/02-RESEARCH.md
@server/lib/supabase-admin.ts
@supabase/migrations/0003_rls_policies.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage bucket and RLS migrations</name>
  <files>
    supabase/migrations/0004_storage_buckets.sql
    supabase/migrations/0005_storage_rls.sql
  </files>
  <action>
    **Migration 0004_storage_buckets.sql:**

    Create one private bucket per existing business unit using INSERT INTO storage.buckets:
    - Bucket naming: `bu-{id}` (e.g., `bu-1`, `bu-42`) — lowercase, hyphens only, satisfies 3-63 char constraint
    - `id` and `name` both set to `bu-{id}` (Supabase requires both fields)
    - `public` = false (private buckets — signed URLs required for access)
    - `file_size_limit` = 10485760 (10 MB in bytes — per user decision)
    - `allowed_mime_types` = ARRAY of: application/pdf, .docx MIME, .xlsx MIME, .pptx MIME, image/png, image/jpeg (per user decision)
    - Use SELECT from public.business_units to dynamically create a bucket for each existing BU
    - Add ON CONFLICT (id) DO NOTHING to make migration idempotent

    Full MIME type array:
    ```
    ARRAY[
      'application/pdf',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'image/png',
      'image/jpeg'
    ]
    ```

    **Migration 0005_storage_rls.sql:**

    Create RLS policies on storage.objects using the same JWT claims pattern from Phase 1:
    - `auth.jwt()->'app_metadata'->'business_units'` returns `[{id, role}]` array

    Three policies:

    1. **SELECT (download)** — `storage_objects_select` for `authenticated` role:
       - USING clause: EXISTS subquery checking that `('bu-' || (elem->>'id')::text) = bucket_id` for any element in the business_units JWT array
       - Any role (viewer/editor/admin) can download

    2. **INSERT (upload)** — `storage_objects_insert` for `authenticated` role:
       - WITH CHECK clause: EXISTS subquery checking bucket_id matches AND `elem->>'role' IN ('admin', 'editor')`
       - Viewers cannot upload

    3. **DELETE** — `storage_objects_delete` for `authenticated` role:
       - USING clause: same as INSERT (admin/editor only)

    All policies use COALESCE with '[]'::jsonb default (Phase 1 pattern — prevents null errors for users with no BU memberships).

    Do NOT create an UPDATE policy — files are immutable (version suffix pattern handles "updates" by creating new files).
  </action>
  <verify>
    - Both SQL files exist and contain valid SQL syntax
    - 0004 contains INSERT INTO storage.buckets with SELECT from business_units
    - 0005 contains exactly 3 CREATE POLICY statements on storage.objects
    - Both use consistent bucket naming `bu-{id}` pattern
    - RLS policies reference `auth.jwt()->'app_metadata'->'business_units'` (matches Phase 1)
  </verify>
  <done>
    Two idempotent SQL migration files ready for Supabase deployment: 0004 creates per-BU private buckets with 10 MB limit and MIME type restrictions; 0005 creates 3 RLS policies (SELECT/INSERT/DELETE) with BU-scoped JWT claims checks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Supabase Storage service module</name>
  <files>server/storage-supabase.ts</files>
  <action>
    Create `server/storage-supabase.ts` — the server-side Supabase Storage service used by all routes.

    **Import:** `supabaseAdmin` from `./lib/supabase-admin` (service-role client — bypasses RLS for server operations).

    **Constants (exported):**
    - `ALLOWED_MIME_TYPES`: array of the 6 accepted MIME types (same as migration)
    - `MAX_FILE_SIZE`: 10485760 (10 MB in bytes)
    - `SIGNED_URL_EXPIRY`: 3600 (1 hour in seconds — reasonable for a reading session, per research recommendation)

    **Functions (all exported):**

    1. `bucketName(buId: number): string` — returns `bu-${buId}`

    2. `storagePath(documentId: number, versionId: number, fileName: string): string`
       - Pattern: `{documentId}/{versionId}/{8-char-uuid-prefix}_{sanitized-filename}`
       - Sanitize filename: replace non-alphanumeric (except `.`, `_`, `-`) with `_`
       - UUID prefix from `crypto.randomUUID().slice(0, 8)` for uniqueness

    3. `async resolveFilename(buId: number, docId: number, versionId: number, originalName: string): Promise<string>`
       - Lists existing objects in the `{docId}/{versionId}/` prefix using `supabaseAdmin.storage.from(bucket).list(prefix)`
       - If no conflict with base name, returns original name
       - If conflict: appends `_v2`, `_v3`, etc. until unique (per user decision: version suffix pattern)
       - Extracts base name and extension using path.basename/path.extname (import `path` from Node)

    4. `async createSignedUploadUrl(buId: number, filePath: string): Promise<{signedUrl: string, token: string, path: string}>`
       - Calls `supabaseAdmin.storage.from(bucketName(buId)).createSignedUploadUrl(filePath)`
       - Throws on error

    5. `async createSignedDownloadUrl(buId: number, filePath: string, forDownload?: string): Promise<string>`
       - Calls `supabaseAdmin.storage.from(bucketName(buId)).createSignedUrl(filePath, SIGNED_URL_EXPIRY, { download: forDownload })`
       - Omit `download` option for inline preview (Content-Disposition: inline)
       - Pass filename string for forced download (Content-Disposition: attachment)
       - Returns `data.signedUrl`

    6. `async deleteStorageObject(buId: number, filePath: string): Promise<void>`
       - Calls `supabaseAdmin.storage.from(bucketName(buId)).remove([filePath])`
       - Throws on error

    7. `async createBucketForBusinessUnit(buId: number): Promise<void>`
       - Calls `supabaseAdmin.storage.createBucket(bucketName(buId), { public: false, fileSizeLimit: MAX_FILE_SIZE, allowedMimeTypes: ALLOWED_MIME_TYPES })`
       - Throws on error (caller should handle "bucket already exists" gracefully)

    8. `validateFileType(mimeType: string): { valid: boolean, message?: string }`
       - Checks if mimeType is in ALLOWED_MIME_TYPES
       - Returns `{ valid: true }` or `{ valid: false, message: "Unsupported file type: {mimeType}. Accepted: PDF, Word, Excel, PowerPoint, PNG, JPEG" }`
       - Per user decision: "clear rejection messages for unsupported types"

    9. `validateFileSize(sizeBytes: number): { valid: boolean, message?: string }`
       - Checks if sizeBytes <= MAX_FILE_SIZE
       - Returns `{ valid: true }` or `{ valid: false, message: "File too large: {sizeInMB} MB. Maximum: 10 MB" }`

    **Do NOT import or reference** the old `s3.ts` module. This is a clean replacement.
  </action>
  <verify>
    - `server/storage-supabase.ts` exists and TypeScript compiles without errors
    - All 9 functions are exported
    - `bucketName(42)` returns `"bu-42"`
    - Module imports `supabaseAdmin` from `./lib/supabase-admin`
    - `validateFileType` rejects unknown MIME types with a clear message
    - `resolveFilename` implements version suffix logic (_v2, _v3)
  </verify>
  <done>
    server/storage-supabase.ts exports all storage operations: bucket naming, path generation, signed URL creation (upload + download), deletion, bucket provisioning, filename conflict resolution, and file validation. All functions use the service-role client via supabaseAdmin.
  </done>
</task>

</tasks>

<verification>
- SQL migration files follow Phase 1 numbering (0004, 0005)
- Bucket naming uses `bu-{id}` pattern consistently across SQL and TypeScript
- RLS policies use identical JWT claims path as Phase 1: `auth.jwt()->'app_metadata'->'business_units'`
- storage-supabase.ts functions match the signatures expected by Plan 02-02 route replacements
- No references to old s3.ts in any new code
</verification>

<success_criteria>
1. Two SQL migration files exist at supabase/migrations/0004_storage_buckets.sql and 0005_storage_rls.sql
2. server/storage-supabase.ts exists and exports bucketName, storagePath, createSignedUploadUrl, createSignedDownloadUrl, deleteStorageObject, resolveFilename, createBucketForBusinessUnit, validateFileType, validateFileSize, ALLOWED_MIME_TYPES, MAX_FILE_SIZE
3. All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-storage-migration/02-01-SUMMARY.md`
</output>
