---
phase: 04-client-migration-cleanup
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - client/src/lib/queryClient.ts
  - client/src/pages/Dashboard.tsx
  - client/src/pages/Documents.tsx
  - client/src/pages/DocumentDetail.tsx
  - client/src/pages/VersionDetail.tsx
  - client/src/pages/Requirements.tsx
  - client/src/pages/ControlDetail.tsx
  - client/src/pages/TestDetail.tsx
  - client/src/pages/RegulatorySources.tsx
  - client/src/pages/FrameworkDetail.tsx
  - client/src/pages/GapAnalysis.tsx
  - client/src/pages/Findings.tsx
  - client/src/pages/AuditTrail.tsx
  - client/src/pages/BusinessUnits.tsx
  - client/src/pages/Audits.tsx
  - client/src/pages/Users.tsx
  - client/src/pages/TrustCenter.tsx
  - client/src/pages/Commitments.tsx
  - client/src/pages/KnowledgeBase.tsx
  - client/src/pages/RiskOverview.tsx
  - client/src/pages/RiskRegister.tsx
  - client/src/pages/RiskLibrary.tsx
  - client/src/pages/RiskActions.tsx
  - client/src/pages/RiskSnapshots.tsx
  - client/src/pages/RiskSettings.tsx
  - client/src/pages/Settings.tsx
autonomous: true
requirements: [CLNT-02]

must_haves:
  truths:
    - "All list/get page queries use supabase.from().select() instead of fetch('/api/...')"
    - "QueryKeys no longer use /api/ prefix — keys are 'documents', 'business-units', etc."
    - "All invalidateQueries and setQueryData calls updated to match new queryKeys"
    - "Mutations still use apiRequest() to call /api/ serverless endpoints for writes"
    - "Stats endpoint remains a serverless function call (multi-table aggregation)"
    - "Empty list states show helpful messages with CTA buttons"
  artifacts:
    - path: "client/src/lib/queryClient.ts"
      provides: "Supabase query helper function for direct reads"
      contains: "supabaseQuery"
    - path: "client/src/pages/Documents.tsx"
      provides: "Documents page using direct Supabase reads"
      contains: "supabase.from"
    - path: "client/src/pages/Dashboard.tsx"
      provides: "Dashboard page — stats query stays as fetch, other reads migrate"
      contains: "supabase.from"
  key_links:
    - from: "client/src/pages/*.tsx"
      to: "supabase.from().select()"
      via: "Direct Supabase reads in queryFn"
      pattern: "supabase\\.from"
    - from: "client/src/pages/*.tsx"
      to: "queryClient.invalidateQueries"
      via: "Updated queryKeys (no /api/ prefix)"
      pattern: 'queryKey.*\\["[a-z]'
---

<objective>
Migrate all React page read operations from `fetch('/api/...')` to direct `supabase.from().select()` queries. Update all queryKeys and invalidation calls to match.

Purpose: Eliminate the Express API round-trip for read operations. RLS enforces access control at the database level — the frontend reads directly from Supabase with the user's JWT.
Output: All ~35 list/get queries use Supabase client; mutations still hit /api/ serverless functions.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-client-migration-cleanup/04-RESEARCH.md
@.planning/phases/04-client-migration-cleanup/04-01-SUMMARY.md
@client/src/lib/queryClient.ts
@client/src/lib/supabase.ts
@shared/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase query helper and migrate core entity pages</name>
  <files>
    client/src/lib/queryClient.ts
    client/src/pages/BusinessUnits.tsx
    client/src/pages/Documents.tsx
    client/src/pages/DocumentDetail.tsx
    client/src/pages/VersionDetail.tsx
    client/src/pages/Requirements.tsx
    client/src/pages/ControlDetail.tsx
    client/src/pages/TestDetail.tsx
    client/src/pages/RegulatorySources.tsx
    client/src/pages/FrameworkDetail.tsx
    client/src/pages/Findings.tsx
    client/src/pages/Audits.tsx
    client/src/pages/AuditTrail.tsx
    client/src/pages/Users.tsx
    client/src/pages/Settings.tsx
  </files>
  <action>
    1. Add to `client/src/lib/queryClient.ts`:
       - Import `supabase` from `@/lib/supabase`
       - Export a helper: `export async function supabaseQuery<T>(table: string, query?: (q: any) => any): Promise<T[]>`
         - Calls `supabase.from(table).select('*')` (or custom query if provided)
         - Throws on error: `if (error) throw error`
         - Returns `data ?? []`
       - Export a single-item helper: `export async function supabaseQuerySingle<T>(table: string, id: number): Promise<T>`
         - Calls `supabase.from(table).select('*').eq('id', id).single()`
         - Throws on error
         - Returns `data`
       - Keep `apiRequest()` and `getQueryFn()` — still needed for mutations and stats

    2. Migrate each page's `useQuery` calls following this pattern:

       **Before (current):**
       ```typescript
       const { data: documents } = useQuery<Document[]>({
         queryKey: ["/api/documents"],
       });
       ```

       **After:**
       ```typescript
       import { supabase } from "@/lib/supabase";

       const { data: documents } = useQuery<Document[]>({
         queryKey: ["documents"],
         queryFn: async () => {
           const { data, error } = await supabase.from("documents").select("*");
           if (error) throw error;
           return data ?? [];
         },
       });
       ```

    3. For each page, also update ALL `invalidateQueries` and `setQueryData` calls to use the new queryKey (drop `/api/` prefix):
       - `queryClient.invalidateQueries({ queryKey: ["/api/documents"] })` becomes `queryClient.invalidateQueries({ queryKey: ["documents"] })`

    4. **Pages to migrate (Task 1 — core entities):**
       - `BusinessUnits.tsx`: `/api/business-units` -> `business_units` table, queryKey `["business-units"]`
       - `Documents.tsx`: `/api/documents` -> `documents` table; also has `/api/business-units` query for the BU filter
       - `DocumentDetail.tsx`: `/api/documents/:id` -> single doc; `/api/documents/:id/versions` -> `document_versions` where `documentId = id`; BU query; also has review_history, approvals subqueries — map each to its table
       - `VersionDetail.tsx`: version + document queries
       - `Requirements.tsx`: `/api/requirements` -> `requirements` table; also references business-units, regulatory-sources
       - `ControlDetail.tsx`: single requirement + related queries
       - `TestDetail.tsx`: single control test + related queries
       - `RegulatorySources.tsx`: `/api/regulatory-sources` -> `regulatory_sources` table
       - `FrameworkDetail.tsx`: single source + requirements
       - `Findings.tsx`: `/api/findings` -> `findings` table; also BU, documents queries
       - `Audits.tsx`: `/api/audits` -> `audits` table
       - `AuditTrail.tsx`: `/api/audit-log` -> `audit_log` table
       - `Users.tsx`: `/api/users` -> `users` table; also BU, roles queries
       - `Settings.tsx` (LookupAdmin): `/api/admin/:table` — these admin endpoints read lookup tables. Migrate to direct `supabase.from(tableName).select('*')` where tableName comes from the slug prop mapping

    5. **Keep as fetch (do NOT migrate reads):**
       - Dashboard `/api/stats` — multi-table aggregation, stays as serverless function
       - Any queries inside mutation `onSuccess` that call `queryClient.invalidateQueries` — update the key but keep the invalidation pattern

    6. **Empty list states (locked decision):** For each page with a list view, ensure the empty state shows a helpful message with a CTA button. Check existing pages — many already have this. For any that show a bare "No data" or empty table, add: a centered message like "No documents yet" with a "Create Document" button (matching the existing create action).

    7. **Table name mapping:** Supabase table names use snake_case. QueryKeys use kebab-case for consistency with URL patterns. Map:
       - `business_units` table -> `["business-units"]` queryKey
       - `document_versions` table -> `["document-versions", docId]` queryKey
       - `regulatory_sources` -> `["regulatory-sources"]`
       - `requirement_mappings` -> `["requirement-mappings"]`
       - `audit_log` -> `["audit-log"]`
       - All other tables match their table name
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Grep for `"/api/` across all files in `client/src/pages/` — only mutation URLs remain (POST/PUT/DELETE calls via `apiRequest()`), no GET-only queryKeys
    - Grep for `supabase.from` in migrated pages — present in each
  </verify>
  <done>
    Core entity pages (15 files) read directly from Supabase. QueryKeys updated. Mutations still call /api/ endpoints. Empty list states have CTA buttons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate remaining pages (risk management, commitments, knowledge base, dashboard, gap analysis, trust center)</name>
  <files>
    client/src/pages/Dashboard.tsx
    client/src/pages/GapAnalysis.tsx
    client/src/pages/TrustCenter.tsx
    client/src/pages/Commitments.tsx
    client/src/pages/KnowledgeBase.tsx
    client/src/pages/RiskOverview.tsx
    client/src/pages/RiskRegister.tsx
    client/src/pages/RiskLibrary.tsx
    client/src/pages/RiskActions.tsx
    client/src/pages/RiskSnapshots.tsx
    client/src/pages/RiskSettings.tsx
  </files>
  <action>
    1. **Migrate remaining page read queries** following the same pattern as Task 1:
       - `Commitments.tsx`: `/api/commitments` -> `commitments` table
       - `KnowledgeBase.tsx`: `/api/knowledge-base` -> `knowledge_base_articles` table (verify table name in schema)
       - `RiskOverview.tsx`: risk summary queries — migrate simple reads, keep computed endpoints as fetch
       - `RiskRegister.tsx`: `/api/risks` -> `risks` table; also BU, risk-categories
       - `RiskLibrary.tsx`: `/api/risk-library` -> check if this is a table or computed — if table, migrate; if computed, keep as serverless
       - `RiskActions.tsx`: `/api/risk-actions` -> `risk_actions` table
       - `RiskSnapshots.tsx`: `/api/risk-snapshots` -> `risk_snapshots` table
       - `RiskSettings.tsx`: `/api/risk-categories` -> `risk_categories` table
       - `TrustCenter.tsx`: trust center data queries
       - `GapAnalysis.tsx`: Migrate simple list reads. The `/api/gap-analysis/refresh` POST stays as a serverless function call.

    2. **Dashboard.tsx special handling:**
       - `/api/stats` endpoint: KEEP as `fetch('/api/stats')` — this is a multi-table aggregation that must stay server-side (see Research pitfall 3)
       - queryKey for stats: update from `["/api/stats"]` to `["stats"]` but keep using `getQueryFn` or explicit fetch in queryFn (since stats comes from serverless function)
       - Any other simple reads on Dashboard (recent documents, BU list): migrate to Supabase
       - Update stats queryFn to: `async () => { const res = await fetch('/api/stats'); if (!res.ok) throw new Error('Failed to fetch stats'); return res.json(); }`

    3. **Update all invalidateQueries calls** in these pages to use new queryKeys.

    4. **Verify empty states** have helpful messages with CTA buttons on all list views.

    5. **Cross-check:** After both tasks, do a codebase-wide search for `queryKey: ["/api/` in `client/src/pages/` — the ONLY remaining `/api/` queryKey should be for endpoints that genuinely need to stay as serverless calls (stats, gap-analysis refresh). All simple table reads should be migrated.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx vite build` succeeds
    - Grep `client/src/pages/` for `queryKey: \["/api/` — only `/api/stats` and any complex computed endpoints remain
    - Grep `client/src/pages/` for `supabase.from` — present across all 25+ page files
    - Grep for `invalidateQueries.*"/api/` — zero matches (all updated to new keys)
  </verify>
  <done>
    All 25+ pages use direct Supabase reads for list/get operations. Stats and gap-analysis-refresh remain as serverless function calls. All queryKeys and invalidation calls updated. Empty list states show CTA buttons.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — full type check
2. `npx vite build` — client build succeeds
3. Grep `client/src/pages/` for remaining `"/api/` in queryKeys — only intentional serverless endpoints (stats, gap-analysis)
4. Grep for `supabase.from` in pages — confirms direct reads across all pages
5. Grep for `invalidateQueries.*"/api/` — zero matches
6. Grep for `apiRequest` in pages — only in `useMutation` calls (writes), not in `useQuery` (reads)
</verification>

<success_criteria>
- All ~35 simple list/get queries use `supabase.from().select()` directly
- Stats endpoint stays as a serverless function call
- All queryKeys use new format (no `/api/` prefix)
- All `invalidateQueries` calls updated to match
- Mutations (create/update/delete) still call `/api/` serverless endpoints via `apiRequest()`
- Empty list states display helpful messages with action buttons
- Build passes (tsc + vite build)
</success_criteria>

<output>
After completion, create `.planning/phases/04-client-migration-cleanup/04-02-SUMMARY.md`
</output>
