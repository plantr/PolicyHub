---
phase: 04-client-migration-cleanup
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - api/business-units.ts
  - api/documents.ts
  - api/document-versions.ts
  - api/requirements.ts
  - api/requirement-mappings.ts
  - api/findings.ts
  - api/audits.ts
  - api/audit-log.ts
  - api/approvals.ts
  - api/users.ts
  - api/risks.ts
  - api/risk-library.ts
  - api/risk-actions.ts
  - api/risk-snapshots.ts
  - api/risk-categories.ts
  - api/commitments.ts
  - api/knowledge-base.ts
  - api/gap-analysis.ts
  - api/ai-jobs.ts
  - api/stats.ts
  - api/admin.ts
  - api/_shared/handler.ts
  - api/_shared/cors.ts
  - scripts/build-api.mjs
  - vercel.json
autonomous: true
requirements: [CLNT-03, CLNP-04]

must_haves:
  truths:
    - "Each route group has its own /api/*.ts serverless function file"
    - "Write operations (POST/PUT/DELETE) with validation and audit logging work through individual serverless functions"
    - "AI analysis and gap-analysis endpoints work as serverless functions"
    - "Stats endpoint works as a serverless function"
    - "vercel.json no longer has the /api/(.*) catch-all rewrite — Vercel auto-discovers individual function files"
    - "Build script produces individual function bundles, not a single api/index.js"
  artifacts:
    - path: "api/documents.ts"
      provides: "Document write operations (POST, PUT, DELETE) as Vercel serverless function"
      contains: "export default"
    - path: "api/_shared/handler.ts"
      provides: "Shared request handling utilities for serverless functions"
      contains: "export"
    - path: "api/_shared/cors.ts"
      provides: "CORS headers for Vercel functions"
      contains: "Access-Control"
    - path: "scripts/build-api.mjs"
      provides: "Multi-entry-point esbuild config for individual function bundles"
      contains: "entryPoints"
    - path: "vercel.json"
      provides: "Updated config without API catch-all rewrite"
      contains: "(?!api/)"
  key_links:
    - from: "api/*.ts"
      to: "server/storage.ts"
      via: "Import storage for database operations"
      pattern: "storage\\."
    - from: "api/*.ts"
      to: "server/lib/supabase-admin.ts"
      via: "Import admin client for service-role operations"
      pattern: "supabaseAdmin"
    - from: "scripts/build-api.mjs"
      to: "api/*.ts"
      via: "Multi-entry esbuild bundle"
      pattern: "entryPoints"
---

<objective>
Break the Express monolith (server/index.ts + server/routes.ts) into individual Vercel serverless function files in /api/. Each route group becomes its own .ts file handling POST/PUT/DELETE operations. Update the build script for multi-entry bundling and remove the vercel.json API catch-all.

Purpose: Move from a single Express function to Vercel-native individual functions — better cold start isolation, clearer code organization, and preparation for Express server removal.
Output: Individual /api/*.ts files handling all write operations, updated build config, vercel.json cleaned up.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-client-migration-cleanup/04-RESEARCH.md
@server/routes.ts
@server/storage.ts
@server/index.ts
@api/_entry.ts
@scripts/build-api.mjs
@vercel.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared utilities and first batch of serverless function files</name>
  <files>
    api/_shared/handler.ts
    api/_shared/cors.ts
    api/business-units.ts
    api/documents.ts
    api/document-versions.ts
    api/requirements.ts
    api/requirement-mappings.ts
    api/findings.ts
    api/audits.ts
    api/audit-log.ts
    api/approvals.ts
    api/users.ts
    api/stats.ts
    api/admin.ts
  </files>
  <action>
    1. Create `api/_shared/cors.ts`:
       - Export a function `setCorsHeaders(res: VercelResponse)` that sets:
         - `Access-Control-Allow-Origin: *` (Vercel handles domain restrictions via project settings)
         - `Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS`
         - `Access-Control-Allow-Headers: Content-Type, Authorization`
       - Export a function `handleCors(req: VercelRequest, res: VercelResponse): boolean` that calls `setCorsHeaders` and if `req.method === 'OPTIONS'` sends 204 and returns true (handled), else returns false

    2. Create `api/_shared/handler.ts`:
       - Import `VercelRequest, VercelResponse` from `@vercel/node`
       - Import `z` from `zod`
       - Export a helper `parseBody<T>(req: VercelRequest, schema: z.ZodSchema<T>): T` that:
         - Parses `req.body` against the Zod schema
         - Throws `{ status: 400, message: zodError.errors[0].message }` on failure
       - Export a helper `sendError(res: VercelResponse, err: unknown)` that:
         - If err has `.status`, use it; else 500
         - If err is ZodError, 400 with first error message
         - Otherwise, 500 with generic message
         - Logs the error with `console.error`
       - Export `getIdParam(req: VercelRequest): number` that extracts and parses the id from query params

    3. Create individual serverless function files. Each file follows this structure:
       ```typescript
       import type { VercelRequest, VercelResponse } from "@vercel/node";
       import { handleCors } from "./_shared/cors";
       import { sendError } from "./_shared/handler";
       import { storage } from "../server/storage";

       export default async function handler(req: VercelRequest, res: VercelResponse) {
         if (handleCors(req, res)) return;
         try {
           switch (req.method) {
             case "GET": { /* ... */ break; }
             case "POST": { /* ... */ break; }
             case "PUT": { /* ... */ break; }
             case "DELETE": { /* ... */ break; }
             default: res.status(405).json({ message: "Method not allowed" });
           }
         } catch (err) { sendError(res, err); }
       }
       ```

    4. **Extract routes from server/routes.ts into individual files.** Read `server/routes.ts` carefully for each route group. For each file, migrate the POST/PUT/DELETE handlers. GET handlers are also included in the serverless functions because:
       - Stats endpoint needs server-side aggregation
       - Mutations need POST/PUT/DELETE
       - Some GET routes are complex (gap-analysis, document versions with PDF operations)
       - Direct Supabase reads handle simple GETs from the client, but the serverless function file should still support GET for API consumers

    5. **File-by-file migration (Task 1 batch):**

       **`api/business-units.ts`:** POST create, PUT update, DELETE. Import validation schemas from `shared/routes.ts`. Include audit log creation on CUD. GET for list and get-by-id (storage.getBusinessUnits, storage.getBusinessUnit).

       **`api/documents.ts`:** POST create (this is the create+upload flow — examine routes.ts for multer usage; for now keep the existing logic but use `storage` directly, without multer — the TUS flow from Phase 2 replaces this), PUT update, DELETE. Audit log on CUD. GET list and get-by-id.

       **`api/document-versions.ts`:** Complex file — handles GET list by doc, GET single, POST create, PUT update, DELETE, plus the upload-url, upload-confirm, download, pdf-to-markdown subpaths. Route based on `req.query.action` or path segments. Preserve all the upload/download/PDF processing logic from routes.ts.

       **`api/requirements.ts`:** CRUD for requirements. GET list/get, POST create, PUT update, DELETE.

       **`api/requirement-mappings.ts`:** CRUD for requirement mappings.

       **`api/findings.ts`:** CRUD + finding evidence subresource.

       **`api/audits.ts`:** CRUD for audits.

       **`api/audit-log.ts`:** GET only (list audit entries).

       **`api/approvals.ts`:** CRUD for approval records.

       **`api/users.ts`:** CRUD for users + role assignment + BU membership management.

       **`api/stats.ts`:** GET only — the multi-table stats aggregation. Copy the stats computation logic from routes.ts directly.

       **`api/admin.ts`:** GET/POST/PUT/DELETE for lookup tables (entity-types, roles, jurisdictions, document-categories, finding-severities, document-statuses). Uses dynamic table name from query parameter.

    6. **Important:** Import `storage` from `../server/storage` — the DatabaseStorage class is the data access layer. Import Zod schemas from `../shared/routes` for input validation. Import `supabaseAdmin` from `../server/lib/supabase-admin` for any storage operations.

    7. **URL parameter handling:** Vercel serverless functions receive path segments via `req.query`. For a file at `api/documents.ts`, a request to `/api/documents?id=5` has `req.query.id = "5"`. For nested operations, use query params: `/api/document-versions?id=3&action=download`. Document this convention in comments.
  </action>
  <verify>
    - All files created in `api/` directory
    - Each file exports a default function with `(req: VercelRequest, res: VercelResponse)` signature
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    14 serverless function files created covering core entities (business-units through admin). Shared utilities (cors, handler) support all functions. Each function imports from server/storage.ts and shared/routes.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create remaining function files, update build script, and update vercel.json</name>
  <files>
    api/risks.ts
    api/risk-library.ts
    api/risk-actions.ts
    api/risk-snapshots.ts
    api/risk-categories.ts
    api/commitments.ts
    api/knowledge-base.ts
    api/gap-analysis.ts
    api/ai-jobs.ts
    scripts/build-api.mjs
    vercel.json
  </files>
  <action>
    1. **Create remaining serverless function files:**

       **`api/risks.ts`:** CRUD for risks table.

       **`api/risk-library.ts`:** CRUD for risk library items.

       **`api/risk-actions.ts`:** CRUD for risk actions.

       **`api/risk-snapshots.ts`:** CRUD + snapshot generation logic.

       **`api/risk-categories.ts`:** CRUD for risk categories.

       **`api/commitments.ts`:** CRUD for commitments.

       **`api/knowledge-base.ts`:** CRUD for knowledge base articles.

       **`api/gap-analysis.ts`:** GET list/get, POST refresh (triggers AI analysis). The refresh handler contains the AI-powered gap analysis logic — copy from routes.ts carefully. This handler dispatches to the AI job queue (ai_jobs table from Phase 3).

       **`api/ai-jobs.ts`:** GET job status by id, and the AI processing dispatch endpoints. Copy the processAiMatchJob, processAiCoverageJob, processAiMapControlsJob processor functions from routes.ts — these are the fire-and-forget AI processors. The dispatch-and-fire pattern from Phase 3 stays: validate → insert ai_job → fire processor → return { jobId, status: 'pending' }.

    2. **Update `scripts/build-api.mjs` for multi-entry bundling:**
       - Change `entryPoints` from `["api/_entry.ts"]` to a glob of all `api/*.ts` files (excluding `api/_shared/*`)
       - Use esbuild's `entryPoints` array or `outdir` (not `outfile`) for multiple outputs
       - Change output from `outfile: "api/index.js"` to `outdir: "api"` with `outExtension: { '.js': '.js' }` or similar
       - Each `api/foo.ts` compiles to `api/foo.js` — Vercel auto-discovers these
       - Keep the same externals list (node_modules packages)
       - Remove the old single `api/index.js` output reference
       - Actually, reconsider: Vercel can bundle serverless functions itself using nft (node file trace). The simpler approach may be to NOT pre-bundle and let Vercel handle it. However, the current setup pre-bundles to inline server/ code. For multi-entry, use esbuild with `outdir`:
         ```javascript
         import { glob } from "node:fs";
         // or use fs.readdirSync to list api/*.ts files (excluding _shared/ and _entry.ts)
         const entries = readdirSync("api")
           .filter(f => f.endsWith(".ts") && !f.startsWith("_"))
           .map(f => `api/${f}`);

         await build({
           entryPoints: entries,
           bundle: true,
           platform: "node",
           format: "esm",
           outdir: "api",
           outExtension: { ".js": ".js" },
           external: externals,
           tsconfig: "tsconfig.json",
           sourcemap: true,
           logLevel: "info",
         });
         ```

    3. **Delete old files:**
       - Remove `api/_entry.ts` (the single-function adapter — no longer needed)
       - Remove `api/index.js` and `api/index.js.map` (old build output)

    4. **Update `vercel.json`:**
       - Remove the `/api/(.*)` -> `/api` rewrite (Vercel auto-discovers individual function files)
       - Keep only the SPA rewrite: `{ "source": "/((?!api/).*)", "destination": "/index.html" }`
       - Keep `buildCommand` but update it: `"npx vite build && node scripts/build-api.mjs"`
       - Keep `outputDirectory: "dist/public"`
       - Final vercel.json:
         ```json
         {
           "$schema": "https://openapi.vercel.sh/vercel.json",
           "buildCommand": "npx vite build && node scripts/build-api.mjs",
           "outputDirectory": "dist/public",
           "rewrites": [
             { "source": "/((?!api/).*)", "destination": "/index.html" }
           ]
         }
         ```

    5. **Verify local build:** Run `node scripts/build-api.mjs` and confirm individual .js files are produced in `api/` for each function.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `node scripts/build-api.mjs` succeeds — produces individual .js files in api/
    - `api/_entry.ts` no longer exists
    - `vercel.json` has only the SPA rewrite, no `/api/(.*)` rewrite
    - `npx vite build` succeeds (client build unaffected)
    - Each `api/*.ts` file exports a default handler function
  </verify>
  <done>
    All route groups have individual serverless function files. Build script produces multi-entry bundles. vercel.json updated to remove API catch-all. api/_entry.ts and old index.js removed.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — type check passes
2. `npx vite build && node scripts/build-api.mjs` — full build pipeline succeeds
3. `ls api/*.js` — shows individual function bundles (documents.js, business-units.js, etc.)
4. `api/_entry.ts` does NOT exist
5. Grep `vercel.json` for `/api/(.*)` — NOT present (removed)
6. Grep `vercel.json` for `(?!api/)` — present (SPA rewrite intact)
7. Every `api/*.ts` file has `export default async function handler`
</verification>

<success_criteria>
- Each route group is an independent serverless function file
- Write operations (POST/PUT/DELETE) with validation and audit logging work in each function
- AI endpoints (gap-analysis refresh, ai-jobs) work as serverless functions
- Stats endpoint works as serverless function
- Build produces individual bundles per function
- vercel.json has no API catch-all — Vercel auto-discovers functions
- Type check and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-client-migration-cleanup/04-03-SUMMARY.md`
</output>
