---
phase: 01-supabase-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/schema.ts
  - server/db.ts
  - drizzle.config.ts
  - package.json
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-03
  - INFRA-04

user_setup:
  - service: supabase
    why: "Database hosting — Supabase project must exist before schema migration"
    env_vars:
      - name: DATABASE_URL
        source: "Supabase Dashboard → Project Settings → Database → Connection string → URI (Transaction mode, port 6543)"
      - name: DATABASE_URL_DIRECT
        source: "Supabase Dashboard → Project Settings → Database → Connection string → URI (Direct connection, port 5432)"
    dashboard_config:
      - task: "Create a new Supabase project (or use existing)"
        location: "https://supabase.com/dashboard → New Project"

must_haves:
  truths:
    - "Drizzle generates SQL migration files from the existing schema including the new user_business_units table"
    - "drizzle-kit migrate applies the migration to Supabase via the direct connection URL (port 5432)"
    - "The db.ts runtime client uses postgres.js with prepare:false for transaction-mode pooler compatibility"
    - "Two separate connection URLs exist — DATABASE_URL (pooler, port 6543) for runtime, DATABASE_URL_DIRECT (direct, port 5432) for migrations"
  artifacts:
    - path: "shared/schema.ts"
      provides: "userBusinessUnits table definition + auth_user_id column on users table"
      contains: "userBusinessUnits"
    - path: "server/db.ts"
      provides: "postgres.js Drizzle client with prepare:false"
      contains: "prepare: false"
    - path: "drizzle.config.ts"
      provides: "Migration config pointing to direct connection URL"
      contains: "DATABASE_URL_DIRECT"
    - path: "migrations/"
      provides: "Generated SQL migration files for all 33 tables"
  key_links:
    - from: "server/db.ts"
      to: "shared/schema.ts"
      via: "import * as schema"
      pattern: "import.*schema.*from.*@shared/schema"
    - from: "drizzle.config.ts"
      to: "DATABASE_URL_DIRECT"
      via: "env var for direct connection"
      pattern: "DATABASE_URL_DIRECT"
---

<objective>
Migrate the database schema to Supabase and configure the two-URL Drizzle connection pattern.

Purpose: Establishes the database foundation — all 32 existing tables plus the new `user_business_units` junction table are deployed to Supabase PostgreSQL. The Drizzle ORM driver is switched from `pg` (node-postgres) to `postgres` (postgres.js) with `prepare: false` for transaction-mode pooler compatibility. This must land before auth, RLS, or any serverless function can operate.

Output: Updated schema, db.ts, drizzle.config.ts, generated SQL migrations, postgres.js driver installed.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-supabase-foundation/01-RESEARCH.md

@shared/schema.ts
@server/db.ts
@drizzle.config.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add user_business_units table and auth_user_id column to schema, switch driver to postgres.js</name>
  <files>shared/schema.ts, server/db.ts, drizzle.config.ts, package.json</files>
  <action>
**1. Install postgres.js and remove pg:**
```bash
npm install postgres
npm uninstall pg @types/pg
```

**2. Add the `user_business_units` junction table to `shared/schema.ts`:**

After the `users` table definition, add:
```typescript
export const userBusinessUnits = pgTable("user_business_units", {
  id: serial("id").primaryKey(),
  userId: text("user_id").notNull(),        // auth.users.id (UUID as text)
  businessUnitId: integer("business_unit_id").notNull().references(() => businessUnits.id),
  role: text("role").notNull(),              // 'admin' | 'editor' | 'viewer'
  createdAt: timestamp("created_at").defaultNow(),
}, (t) => ({
  uniq: unique().on(t.userId, t.businessUnitId),
}));
```

Import `unique` from `drizzle-orm/pg-core` in the import line at the top.

Also add the insert schema, type, and request types for the new table:
```typescript
export const insertUserBusinessUnitSchema = createInsertSchema(userBusinessUnits).omit({ id: true, createdAt: true });
export type UserBusinessUnit = typeof userBusinessUnits.$inferSelect;
```

**3. Add `authUserId` column to existing `users` table:**

Add to the `users` pgTable definition:
```typescript
authUserId: text("auth_user_id"),  // Links to auth.users.id (UUID)
```

This links profile records to Supabase Auth identities. Nullable because existing rows won't have it yet.

**4. Update `server/db.ts` to use postgres.js with prepare:false:**

Replace the entire file:
```typescript
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import * as schema from "@shared/schema";

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

// Transaction-mode pooler (port 6543) — prepare: false is REQUIRED
const client = postgres(process.env.DATABASE_URL, { prepare: false });
export const db = drizzle(client, { schema });
```

Remove the exported `pool` — the postgres.js client manages its own pool. If any file imports `pool` from `db.ts`, update that import to remove it (search for `import { pool }` or `import { db, pool }`).

**5. Update `drizzle.config.ts` to use the direct connection URL:**

```typescript
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL_DIRECT) {
  throw new Error("DATABASE_URL_DIRECT must be set for migrations (direct connection, port 5432)");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL_DIRECT,
  },
});
```

Note: This means `drizzle-kit generate` still works without the env var (it reads schema, not DB), but `drizzle-kit migrate` and `drizzle-kit push` require `DATABASE_URL_DIRECT`. For local development or CI where only `DATABASE_URL` exists, add a fallback:
```typescript
url: process.env.DATABASE_URL_DIRECT || process.env.DATABASE_URL!,
```
  </action>
  <verify>
1. `npm ls postgres` shows postgres.js installed
2. `npm ls pg` returns "not found" (pg removed)
3. `grep -n "user_business_units" shared/schema.ts` shows the new table definition
4. `grep -n "auth_user_id" shared/schema.ts` shows the new column on users table
5. `grep -n "prepare: false" server/db.ts` confirms pooler compatibility
6. `grep -n "DATABASE_URL_DIRECT" drizzle.config.ts` confirms migration config
7. TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
The schema has 33 tables (32 existing + user_business_units), the users table has an auth_user_id column, server/db.ts uses postgres.js with prepare:false, and drizzle.config.ts points to the direct connection URL for migrations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply Drizzle SQL migration to Supabase</name>
  <files>migrations/</files>
  <action>
**1. Generate the SQL migration from schema:**

```bash
npx drizzle-kit generate
```

This reads `shared/schema.ts` and produces a SQL migration file in `./migrations/` (e.g., `0000_initial.sql` or the next sequential number if migrations already exist). The generation step does NOT require a database connection.

**2. Review the generated SQL:**

Open the generated file in `./migrations/` and verify:
- All 33 tables are present (32 existing + `user_business_units`)
- The `user_business_units` table has the `UNIQUE` constraint on `(user_id, business_unit_id)`
- The `users` table includes the `auth_user_id text` column
- Foreign key from `user_business_units.business_unit_id` to `business_units.id` is present

**3. Apply the migration to Supabase:**

This step requires `DATABASE_URL_DIRECT` to be set (the direct connection on port 5432, not the pooler).

```bash
npx drizzle-kit migrate
```

If `DATABASE_URL_DIRECT` is not yet available (Supabase project not provisioned), this step will be completed during execution when the user provides credentials. The migration files are the deliverable — they can be applied later.

**4. Verify tables exist:**

If the migration was applied, run a quick check:
```bash
npx drizzle-kit studio
```
Or verify by connecting to the database and listing tables.
  </action>
  <verify>
1. `ls migrations/*.sql` shows at least one SQL migration file
2. `grep -l "user_business_units" migrations/*.sql` confirms the new table is in the migration
3. `grep -l "auth_user_id" migrations/*.sql` confirms the new column is in the migration
4. If migration applied: connecting to the database and running `SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public'` returns 33
  </verify>
  <done>
SQL migration files exist in `./migrations/` containing DDL for all 33 tables. If the Supabase direct connection was available, the migration has been applied to the database.
  </done>
</task>

</tasks>

<verification>
1. `npm ls postgres` — postgres.js is installed
2. `grep "prepare: false" server/db.ts` — pooler compatibility confirmed
3. `grep "DATABASE_URL_DIRECT" drizzle.config.ts` — migration URL configured
4. `grep "user_business_units" shared/schema.ts` — junction table in schema
5. `ls migrations/*.sql | head -5` — migration files generated
6. TypeScript compilation passes: `npx tsc --noEmit`
</verification>

<success_criteria>
- The Drizzle schema includes 33 table definitions (32 existing + user_business_units)
- The users table has an auth_user_id column for linking to Supabase Auth
- server/db.ts uses postgres.js with prepare:false (no pg dependency)
- drizzle.config.ts reads DATABASE_URL_DIRECT for migrations
- SQL migration file(s) exist in ./migrations/ covering the full schema
</success_criteria>

<output>
After completion, create `.planning/phases/01-supabase-foundation/01-01-SUMMARY.md`
</output>
