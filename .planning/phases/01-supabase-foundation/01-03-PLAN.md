---
phase: 01-supabase-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - supabase/migrations/0003_rls_policies.sql
autonomous: true
requirements:
  - RLS-02
  - RLS-03
  - RLS-04
  - RLS-05

must_haves:
  truths:
    - "An authenticated user can only SELECT rows from BU-scoped tables where business_unit_id matches one of their JWT business_units claims"
    - "An authenticated user with editor or admin role in a BU can INSERT, UPDATE, and DELETE rows in that BU"
    - "An authenticated user with viewer role can only SELECT — no writes"
    - "An unauthenticated (anon) user cannot access any table"
    - "Reference/lookup tables are readable by all authenticated users but not writable via API"
    - "The service role bypasses all RLS policies (used by serverless functions)"
    - "RLS policies use the inverted subquery pattern against jsonb_array_elements for performance"
  artifacts:
    - path: "supabase/migrations/0003_rls_policies.sql"
      provides: "RLS policies for all 33 tables organized by template"
      contains: "auth.jwt()"
  key_links:
    - from: "supabase/migrations/0003_rls_policies.sql"
      to: "auth.jwt()->'app_metadata'->'business_units'"
      via: "JWT claims extraction in policy USING/WITH CHECK clauses"
      pattern: "app_metadata.*business_units"
---

<objective>
Write RLS policies for all 33 tables following four templates: BU-scoped (Template A), reference/lookup (Template B), special (Template C), and audit (Template D).

Purpose: With RLS enabled (Plan 02), all tables currently deny all access. This plan restores access with proper business-unit-scoped isolation. These policies are the core security mechanism — they enforce that users in BU-A cannot see BU-B's data, that viewers cannot write, and that anonymous users are blocked entirely.

Output: A single SQL migration file containing all RLS policies for 33 tables.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-supabase-foundation/01-RESEARCH.md
@.planning/phases/01-supabase-foundation/01-02-SUMMARY.md

@shared/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Template A policies — BU-scoped tables (18 tables)</name>
  <files>supabase/migrations/0003_rls_policies.sql</files>
  <action>
Create `supabase/migrations/0003_rls_policies.sql`. This is a single large migration file organized by template section.

**Template A applies to 18 BU-scoped tables.** These tables have a `business_unit_id` column. Access depends on the user having a membership in that BU, with write access restricted to editor/admin roles.

Tables for Template A:
- `documents` (business_unit_id nullable — NULL = shared template, visible to all authenticated)
- `document_versions` (no direct BU column — scope via JOIN to documents.business_unit_id; for Phase 1, use permissive read for authenticated since BU cannot be derived without a join. Write via service role.)
- `addenda` (business_unit_id NOT NULL)
- `effective_policies` (business_unit_id NOT NULL)
- `approvals` (no BU column — entity-based; for Phase 1, all authenticated can read, writes via service role)
- `review_history` (no BU column — joined via document_id; Phase 1: all authenticated read, writes via service role)
- `requirement_mappings` (business_unit_id nullable)
- `findings` (business_unit_id NOT NULL)
- `finding_evidence` (no direct BU column — joined via finding_id; Phase 1: all authenticated read, writes via service role)
- `policy_links` (no BU column — document graph; Phase 1: all authenticated read, writes via service role)
- `audits` (business_unit_id nullable)
- `commitments` (business_unit_id nullable)
- `knowledge_base_articles` (no BU column; Phase 1: all authenticated read, writes via service role)
- `risks` (business_unit_id nullable)
- `risk_actions` (no direct BU column — joined via risk_id; Phase 1: all authenticated read, writes via service role)
- `risk_snapshots` (business_unit_id nullable)
- `regulatory_profiles` (business_unit_id NOT NULL)
- `users` (business_unit_id column exists but being superseded — scope read by BU membership via JWT for admin user management)

**Reusable SQL helper — define once at the top of the file:**

```sql
-- =============================================
-- RLS POLICIES FOR ALL 33 TABLES
-- =============================================
-- Templates:
--   A: BU-scoped (user must be member of the row's BU)
--   A-shared: BU-scoped with NULL = shared/global (documents)
--   A-indirect: No direct BU column (scope via service role writes, permissive reads)
--   B: Reference/lookup (read-only for all authenticated)
--   C: Special (custom per-table)
--   D: Audit log (read for authenticated, write via service role)
--
-- All policies use TO authenticated — anon role has NO policies (blocked by default)
-- Service role bypasses all RLS by design
--
-- JWT claims path: auth.jwt()->'app_metadata'->'business_units'
-- Each element: {"id": <int>, "role": "admin"|"editor"|"viewer"}
```

**For tables WITH a direct `business_unit_id` column (standard Template A pattern):**

Use the inverted subquery pattern for performance (per RLS-05):

```sql
-- SELECT: any BU member can read
CREATE POLICY "{table}_select" ON public.{table}
FOR SELECT TO authenticated
USING (
  business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
  )
);

-- INSERT: editor or admin in the BU
CREATE POLICY "{table}_insert" ON public.{table}
FOR INSERT TO authenticated
WITH CHECK (
  business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
    WHERE elem->>'role' IN ('admin', 'editor')
  )
);

-- UPDATE: editor or admin in the BU
CREATE POLICY "{table}_update" ON public.{table}
FOR UPDATE TO authenticated
USING (
  business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
    WHERE elem->>'role' IN ('admin', 'editor')
  )
)
WITH CHECK (
  business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
    WHERE elem->>'role' IN ('admin', 'editor')
  )
);

-- DELETE: editor or admin in the BU
CREATE POLICY "{table}_delete" ON public.{table}
FOR DELETE TO authenticated
USING (
  business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
    WHERE elem->>'role' IN ('admin', 'editor')
  )
);
```

Apply this full 4-policy template to these tables with NOT NULL BU ID:
- `addenda`
- `effective_policies`
- `findings`
- `regulatory_profiles`

Apply the same template to these tables with NULLABLE BU ID (add an OR clause for NULL handling):
- `requirement_mappings` — for nullable BU: rows with NULL BU are readable by all authenticated
- `audits` — nullable BU: rows with NULL BU readable by all authenticated
- `commitments` — same
- `risks` — same
- `risk_snapshots` — same

For nullable BU tables, the SELECT policy becomes:
```sql
USING (
  (business_unit_id IS NOT NULL AND business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
  ))
  OR business_unit_id IS NULL
)
```

And INSERT/UPDATE/DELETE keep the strict BU membership check (no writes to NULL BU rows from authenticated — those are service role only):
```sql
WITH CHECK (
  business_unit_id IS NOT NULL AND business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
    WHERE elem->>'role' IN ('admin', 'editor')
  )
)
```

**Special case — `documents` table (Template A-shared):**

The `documents` table has a nullable `business_unit_id` where NULL means "shared template." Per locked decision: shared templates are a read-only pool visible to all BUs.

SELECT policy:
```sql
CREATE POLICY "documents_select" ON public.documents
FOR SELECT TO authenticated
USING (
  (business_unit_id IS NOT NULL AND business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
  ))
  OR business_unit_id IS NULL  -- Shared templates visible to all authenticated
);
```

INSERT/UPDATE/DELETE: editor/admin can write to their own BU's documents only. NULL BU documents (shared templates) are service-role-only writes:
```sql
CREATE POLICY "documents_insert" ON public.documents
FOR INSERT TO authenticated
WITH CHECK (
  business_unit_id IS NOT NULL AND business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
    WHERE elem->>'role' IN ('admin', 'editor')
  )
);
```

**For tables WITHOUT a direct `business_unit_id` column (Template A-indirect):**

These tables join to a parent that has a BU column (e.g., `document_versions` → `documents`, `finding_evidence` → `findings`, `risk_actions` → `risks`). Writing cross-table RLS with JOINs is complex and can cause performance issues. For Phase 1:

- SELECT: all authenticated users can read (permissive)
- INSERT/UPDATE/DELETE: no policy for authenticated (service role only via serverless functions which handle authorization logic)

Apply Template A-indirect to:
- `document_versions` (parent: documents)
- `review_history` (parent: documents)
- `finding_evidence` (parent: findings)
- `policy_links` (parent: documents)
- `risk_actions` (parent: risks)
- `knowledge_base_articles` (no clear BU parent)
- `approvals` (entity-based, mixed parents)

```sql
CREATE POLICY "{table}_select" ON public.{table}
FOR SELECT TO authenticated
USING (true);

-- No INSERT/UPDATE/DELETE policies — writes go through service role
```

**Special case — `users` table (Template C):**

The `users` table is a profile store. Users should see other users in their BU (for assignment dropdowns etc.). Admins need to see all users in their BU for user management.

```sql
-- Users can read their own profile
CREATE POLICY "users_select_own" ON public.users
FOR SELECT TO authenticated
USING (auth_user_id = auth.uid()::text);

-- Admins and members can read users in their BU
CREATE POLICY "users_select_bu" ON public.users
FOR SELECT TO authenticated
USING (
  business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
  )
);

-- Users can update their own profile
CREATE POLICY "users_update_own" ON public.users
FOR UPDATE TO authenticated
USING (auth_user_id = auth.uid()::text)
WITH CHECK (auth_user_id = auth.uid()::text);

-- No INSERT/DELETE for authenticated — managed via service role during invite flow
```
  </action>
  <verify>
1. Count Template A tables: `grep -c "FOR SELECT TO authenticated" supabase/migrations/0003_rls_policies.sql` — should be at least 33 (one SELECT per table, some tables have multiple SELECT policies)
2. Check inverted subquery pattern: `grep -c "jsonb_array_elements" supabase/migrations/0003_rls_policies.sql` — many occurrences (used in every BU-scoped policy)
3. Verify no policies for `anon` role: `grep "TO anon" supabase/migrations/0003_rls_policies.sql` returns nothing
4. Check WITH CHECK exists on INSERT/UPDATE policies: `grep -c "WITH CHECK" supabase/migrations/0003_rls_policies.sql` — multiple occurrences
  </verify>
  <done>
RLS policies for Template A (BU-scoped), Template A-shared (documents with NULL=shared), and Template A-indirect (no direct BU column) tables are written in supabase/migrations/0003_rls_policies.sql.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Template B, C, and D policies — reference tables, special tables, and audit log</name>
  <files>supabase/migrations/0003_rls_policies.sql</files>
  <action>
Append to the same `supabase/migrations/0003_rls_policies.sql` file.

**Template B — Reference/lookup tables (12 tables):**

These tables contain globally shared data (regulations, jurisdictions, categories, etc.). All authenticated users can read; writes are service-role-only.

Apply to:
- `regulatory_sources`
- `requirements`
- `entity_types`
- `roles`
- `jurisdictions`
- `document_categories`
- `finding_severities`
- `document_statuses`
- `risk_categories`
- `impact_levels`
- `likelihood_levels`
- `risk_library`

Pattern for each:
```sql
CREATE POLICY "{table}_select" ON public.{table}
FOR SELECT TO authenticated
USING (true);

-- No INSERT/UPDATE/DELETE policies — service role only
```

**Template C — Special tables:**

**business_units:**
Users should see BUs they belong to. No writes from authenticated — BU management via service role.

```sql
-- Users can read BUs they belong to
CREATE POLICY "business_units_select" ON public.business_units
FOR SELECT TO authenticated
USING (
  id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
  )
);

-- No INSERT/UPDATE/DELETE for authenticated — service role only
```

**user_business_units:**
Already has the `supabase_auth_admin_select` policy from Plan 02's auth hook migration. Add user-facing policies:

```sql
-- Users can read their own memberships
CREATE POLICY "user_business_units_select_own" ON public.user_business_units
FOR SELECT TO authenticated
USING (user_id = auth.uid()::text);

-- Admins can read memberships for BUs they admin
CREATE POLICY "user_business_units_select_admin" ON public.user_business_units
FOR SELECT TO authenticated
USING (
  business_unit_id = ANY(
    SELECT (elem->>'id')::int
    FROM jsonb_array_elements(
      COALESCE(auth.jwt()->'app_metadata'->'business_units', '[]'::jsonb)
    ) AS elem
    WHERE elem->>'role' = 'admin'
  )
);

-- No INSERT/UPDATE/DELETE for authenticated — service role only (invite flow)
```

**Template D — audit_log:**

The audit log has `entity_type` and `entity_id` columns that reference various tables. BU-scoping is complex because `entity_id` could reference any entity. Per research recommendation: for Phase 1, use a permissive read policy for all authenticated users and tighten in Phase 4.

```sql
-- All authenticated users can read audit log entries
-- Phase 1: permissive read; tighten BU-scoping in Phase 4
CREATE POLICY "audit_log_select" ON public.audit_log
FOR SELECT TO authenticated
USING (true);

-- No INSERT/UPDATE/DELETE for authenticated — service role writes audit entries
```

**End of migration file — add a verification comment:**

```sql
-- =============================================
-- VERIFICATION
-- =============================================
-- After applying this migration, run:
--   SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND rowsecurity = false;
-- Expected: zero rows
--
-- To verify policies exist on a table:
--   SELECT policyname, cmd, roles FROM pg_policies WHERE tablename = '{table}';
```
  </action>
  <verify>
1. All 33 tables have at least one policy: `grep "CREATE POLICY" supabase/migrations/0003_rls_policies.sql | grep -oP '"(\w+)_select' | sort -u | wc -l` — should be >= 33 unique table prefixes
2. Template B tables have only SELECT: for each of the 12 reference tables, verify no INSERT/UPDATE/DELETE policies
3. business_units has SELECT restricted to member BUs: `grep "business_units_select" supabase/migrations/0003_rls_policies.sql`
4. user_business_units has own + admin policies: `grep "user_business_units_select" supabase/migrations/0003_rls_policies.sql | wc -l` — at least 2
5. audit_log has permissive SELECT: `grep "audit_log_select" supabase/migrations/0003_rls_policies.sql`
6. No `TO anon` policies anywhere: `grep "TO anon" supabase/migrations/0003_rls_policies.sql` — zero matches
  </verify>
  <done>
supabase/migrations/0003_rls_policies.sql contains RLS policies for all 33 tables across all templates. Anonymous access is blocked (no anon policies). Service role bypass is inherent to Supabase (no extra config needed). All BU-scoped policies use the inverted jsonb_array_elements subquery pattern for performance.
  </done>
</task>

</tasks>

<verification>
1. `wc -l supabase/migrations/0003_rls_policies.sql` — substantial file (likely 300-500+ lines)
2. `grep -c "CREATE POLICY" supabase/migrations/0003_rls_policies.sql` — many policies (expect 60-80+)
3. `grep "TO anon" supabase/migrations/0003_rls_policies.sql` — zero matches (anon blocked)
4. `grep -c "jsonb_array_elements" supabase/migrations/0003_rls_policies.sql` — many occurrences (inverted pattern used)
5. Every table has at least a SELECT policy — verify by comparing policy table names against the full list of 33 tables
6. If applied to database: `SELECT tablename, policyname FROM pg_policies WHERE schemaname = 'public' ORDER BY tablename` shows policies on all tables
</verification>

<success_criteria>
- All 33 tables have at least one SELECT policy for the authenticated role
- BU-scoped tables enforce business_unit_id matching via JWT claims
- Editor/admin role check is on all INSERT/UPDATE/DELETE policies for BU-scoped tables
- Reference tables are read-only for authenticated, no write policies
- No policies grant access to the anon role
- Service role bypasses RLS by design (no configuration needed)
- The inverted subquery pattern (jsonb_array_elements) is used consistently
- Shared templates (documents with NULL business_unit_id) are visible to all authenticated users
</success_criteria>

<output>
After completion, create `.planning/phases/01-supabase-foundation/01-03-SUMMARY.md`
</output>
