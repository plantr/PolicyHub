---
phase: 01-supabase-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - supabase/migrations/0001_enable_rls.sql
  - supabase/migrations/0002_auth_hook.sql
autonomous: true
requirements:
  - AUTH-05
  - RLS-01
  - RLS-06

must_haves:
  truths:
    - "RLS is enabled on every public table — the query SELECT tablename FROM pg_tables WHERE schemaname='public' AND rowsecurity=false returns zero rows"
    - "The Custom Access Token Hook function exists and injects per-BU role map into JWT app_metadata claims"
    - "The supabase_auth_admin role has SELECT access on user_business_units so the hook can read memberships"
  artifacts:
    - path: "supabase/migrations/0001_enable_rls.sql"
      provides: "ALTER TABLE ENABLE ROW LEVEL SECURITY for all 33 tables"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "supabase/migrations/0002_auth_hook.sql"
      provides: "PL/pgSQL Custom Access Token Hook function with permissions"
      contains: "custom_access_token_hook"
  key_links:
    - from: "supabase/migrations/0002_auth_hook.sql"
      to: "public.user_business_units"
      via: "SELECT query inside hook function"
      pattern: "FROM public.user_business_units"
    - from: "supabase/migrations/0002_auth_hook.sql"
      to: "supabase_auth_admin"
      via: "GRANT SELECT permission"
      pattern: "GRANT SELECT ON TABLE public.user_business_units TO supabase_auth_admin"
---

<objective>
Enable Row Level Security on all 33 tables and install the Custom Access Token Hook that injects per-BU role claims into JWTs.

Purpose: RLS enablement is the security gate — once enabled, tables deny all access by default until explicit policies are added (Plan 03). The Custom Access Token Hook is the mechanism that makes the per-BU role map available in every JWT, which every RLS policy will reference. These two pieces MUST land before policies can be written.

Output: Two SQL migration files in `supabase/migrations/` — one for RLS enablement, one for the auth hook.
</objective>

<execution_context>
@/Users/robert.plant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robert.plant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-supabase-foundation/01-RESEARCH.md
@.planning/phases/01-supabase-foundation/01-01-SUMMARY.md

@shared/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS enablement migration for all 33 tables</name>
  <files>supabase/migrations/0001_enable_rls.sql</files>
  <action>
Create the directory `supabase/migrations/` if it doesn't exist.

Create `supabase/migrations/0001_enable_rls.sql` with ALTER TABLE ... ENABLE ROW LEVEL SECURITY for every public table. The complete list of 33 tables:

```sql
-- Enable Row Level Security on all public tables
-- This migration locks down all tables — access requires explicit RLS policies

-- Business units & regulatory profiles
ALTER TABLE public.business_units ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.regulatory_profiles ENABLE ROW LEVEL SECURITY;

-- Regulatory sources & requirements (reference/lookup tables)
ALTER TABLE public.regulatory_sources ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.requirements ENABLE ROW LEVEL SECURITY;

-- Documents & versions
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.addenda ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.effective_policies ENABLE ROW LEVEL SECURITY;

-- Approvals & audit trail
ALTER TABLE public.approvals ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.review_history ENABLE ROW LEVEL SECURITY;

-- Requirement mappings
ALTER TABLE public.requirement_mappings ENABLE ROW LEVEL SECURITY;

-- Findings & evidence
ALTER TABLE public.findings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.finding_evidence ENABLE ROW LEVEL SECURITY;

-- Policy links
ALTER TABLE public.policy_links ENABLE ROW LEVEL SECURITY;

-- Audits
ALTER TABLE public.audits ENABLE ROW LEVEL SECURITY;

-- Commitments
ALTER TABLE public.commitments ENABLE ROW LEVEL SECURITY;

-- Knowledge base
ALTER TABLE public.knowledge_base_articles ENABLE ROW LEVEL SECURITY;

-- Risk management
ALTER TABLE public.risks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.risk_library ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.risk_actions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.risk_snapshots ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.risk_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.impact_levels ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.likelihood_levels ENABLE ROW LEVEL SECURITY;

-- Users & roles
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_business_units ENABLE ROW LEVEL SECURITY;

-- Administration reference tables
ALTER TABLE public.entity_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.jurisdictions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.document_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.finding_severities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.document_statuses ENABLE ROW LEVEL SECURITY;
```

Count: 33 tables total (32 existing + user_business_units). The acceptance query `SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND rowsecurity = false` must return zero rows after applying this migration.

**Important:** After this migration, all tables deny access by default to non-superuser roles. The service role (postgres) still has full access. RLS policies (Plan 03) will restore access for the `authenticated` role.
  </action>
  <verify>
1. `wc -l supabase/migrations/0001_enable_rls.sql` — file has at least 33 ALTER TABLE statements
2. `grep -c "ENABLE ROW LEVEL SECURITY" supabase/migrations/0001_enable_rls.sql` returns 33
3. All 33 table names appear: verify with `grep "ALTER TABLE" supabase/migrations/0001_enable_rls.sql | wc -l` returns 33
  </verify>
  <done>
supabase/migrations/0001_enable_rls.sql exists with ENABLE ROW LEVEL SECURITY for all 33 public tables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Custom Access Token Hook migration with permissions</name>
  <files>supabase/migrations/0002_auth_hook.sql</files>
  <action>
Create `supabase/migrations/0002_auth_hook.sql` with the PL/pgSQL function that Supabase Auth calls before issuing every JWT.

The hook reads from `public.user_business_units` and injects a per-BU role map array into `app_metadata.business_units`. The JWT claims will look like:

```json
{
  "app_metadata": {
    "business_units": [
      { "id": 1, "role": "admin" },
      { "id": 3, "role": "viewer" }
    ]
  }
}
```

Full migration SQL:

```sql
-- Custom Access Token Hook
-- Injects per-BU role map into JWT app_metadata claims
-- Called by Supabase Auth on every token issuance (login, refresh)

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
STABLE  -- reads DB, doesn't write
AS $$
DECLARE
  claims         JSONB;
  bu_memberships JSONB;
BEGIN
  -- Build array of {id, role} objects for all BU memberships
  SELECT COALESCE(
    jsonb_agg(
      jsonb_build_object('id', business_unit_id, 'role', role)
      ORDER BY business_unit_id
    ),
    '[]'::jsonb
  )
  INTO bu_memberships
  FROM public.user_business_units
  WHERE user_id = (event->>'user_id');

  claims := event->'claims';

  -- Ensure app_metadata exists
  IF jsonb_typeof(claims->'app_metadata') IS NULL THEN
    claims := jsonb_set(claims, '{app_metadata}', '{}');
  END IF;

  -- Inject business_units array into app_metadata
  claims := jsonb_set(claims, '{app_metadata,business_units}', bu_memberships);

  RETURN jsonb_set(event, '{claims}', claims);
END;
$$;

-- Permissions: supabase_auth_admin must be able to execute the hook
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;

-- Revoke from roles that should NOT call the hook directly
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

-- CRITICAL: The hook's SELECT on user_business_units needs explicit permission
-- because RLS is enabled on that table. Add a policy for supabase_auth_admin.
CREATE POLICY "supabase_auth_admin_select" ON public.user_business_units
FOR SELECT TO supabase_auth_admin
USING (true);

-- Also grant the underlying table access
GRANT SELECT ON TABLE public.user_business_units TO supabase_auth_admin;
```

**Post-migration manual step (handled by executor):** After applying this migration, the hook must be enabled in the Supabase Dashboard:
- Navigate to: Authentication → Hooks → Custom Access Token
- Select function: `public.custom_access_token_hook`
- Save

This dashboard step is surfaced as a checkpoint in the overall phase, not in this plan (automation-first: the SQL is applied automatically; the dashboard toggle is a human action).
  </action>
  <verify>
1. `cat supabase/migrations/0002_auth_hook.sql | grep "custom_access_token_hook"` — function name present
2. `grep "supabase_auth_admin" supabase/migrations/0002_auth_hook.sql | wc -l` — at least 4 lines (GRANT USAGE, GRANT EXECUTE, REVOKE, policy + GRANT SELECT)
3. `grep "bu_memberships" supabase/migrations/0002_auth_hook.sql` — variable used in function
4. `grep "app_metadata" supabase/migrations/0002_auth_hook.sql` — claims injection present
  </verify>
  <done>
supabase/migrations/0002_auth_hook.sql contains the Custom Access Token Hook function that injects per-BU role map into JWT claims, with correct GRANT/REVOKE permissions and an RLS policy allowing supabase_auth_admin to read user_business_units.
  </done>
</task>

</tasks>

<verification>
1. `ls supabase/migrations/` — both 0001_enable_rls.sql and 0002_auth_hook.sql exist
2. `grep -c "ENABLE ROW LEVEL SECURITY" supabase/migrations/0001_enable_rls.sql` — returns 33
3. `grep "custom_access_token_hook" supabase/migrations/0002_auth_hook.sql` — hook function exists
4. `grep "supabase_auth_admin_select" supabase/migrations/0002_auth_hook.sql` — RLS policy for hook exists
5. If applied to database: `SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND rowsecurity = false` returns zero rows
</verification>

<success_criteria>
- supabase/migrations/0001_enable_rls.sql enables RLS on all 33 public tables
- supabase/migrations/0002_auth_hook.sql creates the Custom Access Token Hook function
- The hook injects a per-BU role map into app_metadata.business_units
- supabase_auth_admin has SELECT permission on user_business_units (via policy and GRANT)
- The hook function is GRANTed to supabase_auth_admin and REVOKEd from authenticated/anon/public
</success_criteria>

<output>
After completion, create `.planning/phases/01-supabase-foundation/01-02-SUMMARY.md`
</output>
